[{"title":"Java中自动类型转换","date":"2017-03-02T01:25:26.000Z","path":"2017/03/02/Java中自动类型转换/","text":"自动类型转换遵循下面的规则：1.若参与运算的数据类型不同，则先转换成同一类型，然后进行运算。2.转换按数据长度增加的方向进行，以保证精度不降低。例如int型和long型运算时，先把int量转成long型后再进行运算。3.所有的浮点运算都是以双精度进行的，即使仅含float单精度量运算的表达式，也要先转换成double型，再作运算。4.char型和short型参与运算时，必须先转换成int型。5.在赋值运算中，赋值号两边的数据类型不同时，需要把右边表达式的类型将转换为左边变量的类型。如果右边表达式的数据类型长度比左边长时，将丢失一部分数据，这样会降低精度。下图表示了类型自动转换的规则：","tags":[]},{"title":"Java中的强、软、弱、虚引用","date":"2017-02-28T03:13:52.000Z","path":"2017/02/28/Java中的强、软、弱、虚引用/","text":"基本介绍Java提供了4种引用类型，分别是强引用、软引用（SoftReference）、弱引用（WeakReference）和虚引用（PhantomReference），另外还要一个ReferenceQueue引用队列。引用和引用队列之间的关系对GC垃圾回收有很大的关系。Java中一个很特殊的东西就是垃圾自动回收机制(Garbage Collection，GC),GC可以自动管理内存，开发者不需要手动调用方法回收内存。Java中GC会监控一个对象的运行状态，包括对象的申请、引用、被引用、赋值等，当一个对象没有引用时，就到了被GC回收的时候。 Android中采用了标注与清理（Mark and Sweep）回收算法。 从“GC Roots”开始循环整个内存，当发现有对象不能直接或者间接的到达GC Roots时证明这个对象就应该被GC回收掉了。 如果我们不再需要的对象资源仍然与GC Roots存在可达路径，导致该资源无法被GC回收。 在Android中，每一个应用程序对应有一个单独的Dalvik虚拟机实例，而每一个Dalvik虚拟机的大小是固定的（如32M，可以通过ActivityManager.getMemoryClass()获得）。这意味着我们可以使用的内存不是无节制的。所以即使有着GC帮助我们回收无用内存，还是需要在开发过程中注意对内存的引用。否则，就会导致内存泄露。 1. 强引用(Strong reference) 强引用不会被GC回收掉，举个栗子： Object obj = new Object(),这里的obj就是一个强引用。如果一个对象具有强引用，垃圾回收器是绝对不会回收的。当内存不足时，Java虚拟机宁愿爆出OOM错误也不会回收强引用对象来解决内存不足的问题。假设有对象A和对象B，A中存在B的引用，那么B的生命周期不会比A短，如果在A中不对B赋值null的话，只有回收A的时候才能把B回收掉。 2. 软引用(Soft reference)软引用会在内存不足的时候由GC回收掉，软引用一般用于处理缓存数据。 3. 弱引用(Weak reference)弱引用在GC遍历内存时就会被回收掉，不管内存是否不足。如果一个对象的所有引用都是弱引用，该对象一定会被回收。 4. 虚引用一个只被虚引用持有的对象可能会在任何时候被GC回收。虚引用对对象的生存周期完全没有影响，也无法通过虚引用来获取对象实例，仅仅能在对象被回收时，得到一个系统通知（只能通过是否被加入到ReferenceQueue来判断是否被GC，这也是唯一判断对象是否被GC的途径） ß","tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"}]},{"title":"android：largeHeap属性的用法","date":"2017-02-26T15:13:29.000Z","path":"2017/02/26/android：largeHeap属性的用法/","text":"如果遇到OutOfMemoryError这样的崩溃，产生的原因主要有两部分，一时内存太小不够用了，二是代码有误，不能及时释放内存，基本后者的情况遇到的最多。这时，我们可以考虑使用android:largeHeap属性来解决内存不够用的问题。 基础概念我们先了解一下关于程序设计中关于内存的基础概念。 通常情况下，一个Android程序运行时会启动一个DVM虚拟机。 虚拟机运行时一般分为堆和栈两大部门。（关于堆和栈的理解以后再讲） 栈是储存方法调用的一片内存区域。 堆内存占用了虚拟机大部分的内存空间，程序执行时产生的对象就分配在堆内存中。 如果堆内存没用可用的空间来产生对象，JVM会抛出java.lang.OutOfMemoryError异常。 largeHeap的介绍如果开启了largeHeap后，程序会请求系统给予分配更大的内存空间。使用方法如下： 1234567&lt;application android:icon=\"@drawable/icon\" android:allowBackup=\"false\" android:label=\"@string/app_name\" android:debuggable=\"true\" android:theme=\"@android:style/Theme.Black\" android:largeHeap=\"true\"&gt; largeHeap 有多大通过两个方法可以得到。 ActivityManager.getMemoryClass()获得内用正常情况下内存的大小 ActivityManager.getLargeMemoryClass()可以获得开启largeHeap最大的内存大小 Android系统中文件路径/system/build.prop下可以得到结果。 123456dalvik.vm.heapstartsize=8mdalvik.vm.heapgrowthlimit=192mdalvik.vm.heapsize=512mdalvik.vm.heaptargetutilization=0.75dalvik.vm.heapminfree=2mdalvik.vm.heapmaxfree=8m dalvik.vm.heapstartsize=8m 这一项用来设置堆内存的初始大小。 dalvik.vm.heapgrowthlimit=192m 这一项用来设置一个标准应用的最大内存大小，即是没有使用过largeHeap的内存大小。 dalvik.vm.heapsize=512m 相当于虚拟机的 -Xmx配置，该项设置了使用android:largeHeap的应用的最大堆内存大小。 dalvik.vm.heaptargetutilization=0.75 相当于虚拟机的 -XX:HeapTargetUtilization,该项用来设置当前理想的堆内存利用率。其取值位于0与1之间。当GC进行完垃圾回收之后，Dalvik的堆内存会进行相应的调整，通常结果是当前存活的对象的大小与堆内存大小做除法，得到的值为这个选项的设置，即这里的0.75。注意，这只是一个参考值，Dalvik虚拟机也可以忽略此设置。 dalvik.vm.heapminfree=2m与dalvik.vm.heapmaxfree=8m dalvik.vm.heapminfree对应的是-XX:HeapMinFree配置，用来设置单次堆内存调整的最小值。dalvik.vm.heapmaxfree对应的是-XX:HeapMaxFree配置，用来设置单次堆内存调整的最大值。通常情况下，还需要结合上面的 -XX:HeapTargetUtilization的值，才能确定内存调整时，需要调整的大小。 largeHeap需要权限吗只需要简单在Application元素上加入android:largeHeap=“true”就能正常使用，不需要权限。 largeHeap对GC的影响拥有了更多的内存，是不是就意味着要花更多的时间遍历对象垃圾回收呢？其实不然。 首先largeHeap自Android 4.0开始支持，而并发的垃圾回收方式从Android 2.3开始引入。 在引入并发垃圾回收之前，系统采用了Stop-the-World回收方式，进行一次垃圾回收通常消耗几百毫秒，这是很影响交互和响应的。 引入并发垃圾回收之后,在GC开始和结束的阶段会有短暂的暂停时间，通常在10毫秒以内。 因此在支持largeHeap的系统上都采用了并发垃圾回收，GC的Pause Time不会很长，对交互响应影响甚微。 慎用largeHeap对于largeHeap的使用，我们该持有的谨慎的态度，largeHeap可以使用，但是要谨慎。 对于本身对内存要求过大的图片或者视频应用，我们可以使用largeHeap。","tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"}]},{"title":"聊一聊单例模式","date":"2017-02-16T06:44:01.000Z","path":"2017/02/16/聊一聊单例模式/","text":"单例模式是Android项目中最常用的设计模式。 饿汉式,通过静态变量实现。常驻内存，不使用时资源浪费。 12345678910class SingleInstance &#123; private static SingleInstance sInstance = new SingleInstance(); private SingleInstance() &#123; &#125; public static SingleInstance getInstance() &#123; return sInstance; &#125;&#125; 懒汉式，第一次使用时创建，解决饿汉式的资源浪费问题，但是有并发问题。 1234567891011121314class SingleInstance() &#123; private static SingleInstance sInstance; private SingleInstance() &#123; &#125; public static SingleInstance getInstance() &#123; if (null == sInstance )&#123; sInstance = new SingleInstance(); &#125; return sInstance; &#125;&#125; synchronized修饰符，可以解决懒汉式中多线程并发的问题。但是用在getInstance方法上会导致性能下降，而且getInstance方法会调用多次。 123456789101112class SingleInstance &#123; private static SingleInstance sInstance; private SingleInstance() &#123; &#125; public synchronized static getInstance() &#123; if (null == sInstance )&#123; sInstance = new SingleInstance(); &#125; return sInstance; &#125;&#125; 双重判断模式 1234567891011121314151617class SingleInstance&#123; private static SingleInstance sInstance; private SingleInstance() &#123; &#125; public static SingleInstance getInstance() &#123; if(null == sInstance) &#123; synchronized(SingleInstance.class)&#123; if(null == sInstance) &#123; sInstance = new SingleInstance(); &#125; &#125; &#125; return sInstance; &#125;&#125; volatile关键字，volatile关键字是轻型的synchronized,","tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"}]}]