[{"title":"关于as安装app失败的问题","date":"2017-12-12T05:14:52.000Z","path":"2017/12/12/安装app失败的问题/","text":"AS 安装APP失败首先考虑手机中是否有该APP未卸载 在考虑AS Cleran 或者 invalidate Caches 如果是小米手机，关闭优化选项 如果是vivo等手机，尝试关闭install run","tags":[{"name":"日常技术","slug":"日常技术","permalink":"http://yoursite.com/tags/日常技术/"}]},{"title":"猫扑素数","date":"2017-07-23T13:49:59.000Z","path":"2017/07/23/猫扑素数/","text":"如以 2 开头, 之后跟任意多个 3 的十进制整数而且是个素数, 则它是猫扑素数. 如 2, 23, 233, 2333, 23333 都是猫扑素数。 123456789101112131415161718192021222324252627282930/** * 用于判断一个数是否为猫扑数，若为猫扑数，返回true,否则返回false * @param i 输入的值 * @return */public boolean isMopNumber (int i )&#123; if (i &lt; 10 ) return i == 2; else return (i % 10 == 3 ) &amp;&amp; isMopNumber (i / 10 );&#125;/** * 用于判断一个数是否为素数，若为素数，返回true,否则返回false * * @param a 输入的值 * @return true、false */public static boolean isPrime(int a) &#123; boolean flag = true; if (a &lt; 2) &#123;// 素数不小于2 return false; &#125; else &#123; for (int i = 2; i &lt;= Math.sqrt(a); i++) &#123; if (a % i == 0) &#123;// 若能被整除，则说明不是素数，返回false flag = false; break;// 跳出循环 &#125; &#125; &#125; return flag;&#125;","tags":[]},{"title":"try代码块中含return语句时代码执行顺序","date":"2017-05-10T09:07:38.000Z","path":"2017/05/10/try代码块中含return语句时代码执行顺序/","text":"举了例子先 123456789101112public static void main(String[] args) &#123; int result = test(); System.out.println(result);&#125; public static int test() &#123; int t = 0; try &#123; return t; &#125; finally &#123; ++t; &#125;&#125; \u0010Java面试的时候经常会问到上面这个问题，result的打印结果是多少？答案是0。我们都知道，在上述例子中，执行顺序是先finally再return。但是这个的答案居然是0。原因就是return的时候不会直接返回t值。值引用的时候引用的是","tags":[]},{"title":"APK都有哪些东西","date":"2017-05-03T06:48:38.000Z","path":"2017/05/03/APK都有哪些东西/","text":"APK其实就是一个后缀名为.apk的压缩文件，解压缩出来以后如下 APK 描述 assert目录 存放需要打包到APK中的静态文件 lib目录 程序以来的nativie库 res目录 存放应用程序的资源 META-INF目录 存放应用程序签名和证书的目录 AndroidManifest.xml 应用程序的配置文件 classes.dex dex可执行文件 resource.arsc 资源配置文件","tags":[{"name":"猎豹面试","slug":"猎豹面试","permalink":"http://yoursite.com/tags/猎豹面试/"}]},{"title":"png和jpg的区别","date":"2017-05-02T08:51:30.000Z","path":"2017/05/02/png和jpg的区别/","text":"猎豹二面的时候问到关于PNG和JPG的区别，下面详细介绍一下他们的优点和缺点。 JPG的优点 JPG使用失真压缩方法，图片所占内存小 JPG不支持透明度设定 JPG质量低，且有锯齿 PNG的优点 PNG使用无损压缩方法，图片所占内存大 PNG有8位、24位和32位三种类型，8位的png支持2的8次方（256）种颜色，8位的png其实支持不透明，索引透明和alpha透明。24位的png支持2的24次方种颜色，表现为不透明。32位的png其实在24的png上增加8位的透明信息，支持不同程度的半透效果。","tags":[{"name":"猎豹面试","slug":"猎豹面试","permalink":"http://yoursite.com/tags/猎豹面试/"}]},{"title":"Map、List的区别","date":"2017-04-27T13:17:43.000Z","path":"2017/04/27/Map、List的区别/","text":"","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"JVM和DVM的区别","date":"2017-04-25T09:42:24.000Z","path":"2017/04/25/JVM和DVM的区别/","text":"首要差别Dalvik: 基于寄存器，编译和运行都会更快些JVM: 基于栈, 编译和运行都会慢些 字节码的区别Dalvik: 执行.dex格式的字节码，是对.class文件进行压缩后产生的,文件变小JVM: 执行.class格式的字节码JAVA –》.java文件 -&gt; .class文件 -&gt; .jar文件Android –》.java文件 –&gt; .class文件 -&gt; .dex文件 运行环境的区别 Dalvik : 一个应用启动都运行一个单独的虚拟机运行在一个单独的进程中JVM: 只能运行一个实例, 也就是所有应用都运行在同一个JVM中 Java基于栈的架构.栈是内存上面的一段连续的存储空间Android基于寄存器的架构.寄存器是CPU上面的一块存储空间所以，CPU直接访问自己上面的一块空间的数据的效率肯定要大于访问内存上面的数据","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/操作系统/"}]},{"title":"在Mac上下载与编译Aosp Android源码","date":"2017-03-30T10:46:53.000Z","path":"2017/03/30/在Mac上下载与编译Aosp Android源码/","text":"这里采用的是清华的镜像，国内可以直接访问，速度很快。如果想用Android官方镜像可以在下面找到地址。https://android.googlesource.com/platform/manifestAndroid官方给的下载编译源码的文章：http://source.android.com/source/initializing.html其实很多文章都参考了上面官方的文章，本文也不例外，只是把自己遇到的问题和坑记录一下，防止以后在掉进去。 配置Mac环境第一步 在Mac上创建一个大小写敏感的分区Mac上默认是不区分文件名大小写的，但是Android源码的目录中是区分大小写的，所以需要创建一块分区来存放解压后的源码文件，分区也就是通常意义上的镜像等意思。 1$ sudo hdiutil create -type SPARSE -fs &apos;Case-sensitive Journaled HFS+&apos; -size 80g ~/android.dmg 这里创建的大小为80G的硬盘，如果你的硬盘够大，最好创建的大一些，比如100G。因为我在编译源码的时候发现80G有时还不够用。对于这个大小下面可以用语句来更改： 1$ sudo hdiutil resize -size 100g ~/android.dmg.sparseimage 这里是100G。 第二步 加载这块分区直接上语句： 1$ sudo hdiutil attach ~/android.dmg.sparseimage -mountpoint /Volumes/android 第三步 下载安装辅助工具 安装Xcode 安装MacPorts，找和自己系统一致的版本https://distfiles.macports.org/MacPorts/ 通过MacPorts按装make： 1$ POSIXLY_CORRECT=1 sudo port install gmake libsdl git gnupg 第四步 打开文件描述限制mac系统默认只能打开1024个文件，而编译源码的时候可能会超过这个限制，所以需要在个人配置文件.bash_profile中做出设置。添加一下内容: 12#set the number of open files to be 1024ulimit -S -n 1024 至于~/.bash_profile你可以这样打开： 启动终端Terminal 进入当前用户的home目录输入cd~ 创建.bash_profile输入touch .bash_profile 编辑.bash_profile文件输入open -e .bash_profile 添加上面内容，保存文件，关闭.bash_profilesource ~/.bash_profile 第五步 安装RepoRepo是一个辅助于Git管理Android版本及分支的工具。下载好的repo会在bin目录下。 1234$ mkdir ~/bin$ PATH=~/bin:$PATH$ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo$ chmod a+x ~/bin/repo 第四行的意思是给予/bin/repo读写权限 第六步 下载源码清华大学TUNA镜像源https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar随便下载到哪里都可以，下载完成后在本目录执行以下语句 123$ tar xf aosp-latest.tar$ cd AOSP # 解压得到的 AOSP 工程目录$ repo sync # 正常同步一遍即可得到完整目录, 这一步时间很长，耐心等待。 如果出现问题卡主了，就重新执行repo snyc，如果想停止可以Ctrl+C。Repo 是断点续传的，但如果断了还是需要多下载一些重复下载的东西。如果是执行repo错了的话，就重新执行第五步 第七步 进入分区先把上面解压和同步完的源码拷贝到你的分区中，注意要把整个aosp文件夹都拷过去，只要拷贝到分区根目录就行。接着我们进入这个aosp目录中 1$ cd /Volumes/android/AOSP/ 如果出现找不到文件夹的错误信息，注意看是否挂载了分区 第八步 编译 123$ source build/envsetup.sh$ lunch aosp_arm-eng$ sudo make -j4 j4是执行4个核心编译的意思。不用管编译的过程出现多少警告，只有出现错误的时候才需要解决。解决错误以后重新执行sudo make -j4就行了。编译成功后继续在源码根目录执行以下语句 12$ mmm development/tools/idegen/$ sh ./development/tools/idegen/idegen.sh 完成后就会在aosp根目录生成android.ipr文件，在就Android stuido中打开这个ipr文件就算是打开源码了。等indexing执行完成后就可以正常阅读了。 遇到的编译错误没有配置ANDROID_JAVA_HOME环境变量，在bash_profile中配置成和JAVA_HOME一样即可。我在配置后编译还是会出现同样的错误，最后在找了一天没有结果的时候重启电脑就好了。 fatal error: linux/netfilter/xt_DSCP.h: No such file or directory这个错误的解决办法是创建一个名为xt_DSCP.h（注意大写）的文件，放在aosp文件中的external/iptables/extensions/../include/linux/netfilter下，xt_DSCP.h内容如下 123456789101112131415161718192021222324/** based on ipt_FTOS.c (C) 2000 by Matthew G. Marsh &lt;mgm@paktronix.com&gt;* This software is distributed under GNU GPL v2, 1991** See RFC2474 for a description of the DSCP field within the IP Header.** xt_DSCP.h,v 1.7 2002/03/14 12:03:13 laforge Exp*/#ifndef _XT_DSCP_TARGET_H#define _XT_DSCP_TARGET_H#include &lt;linux/netfilter/xt_dscp.h&gt;#include &lt;linux/types.h&gt;/* target info */struct xt_DSCP_info &#123; __u8 dscp;&#125;;struct xt_tos_target_info &#123; __u8 tos_value; __u8 tos_mask;&#125;;#endif /* _XT_DSCP_TARGET_H */ bash_profile文件如下: 123456789101112131415161718export PATH=$&#123;PATH&#125;:/Users/xjw/Library/Android/sdk/platform-toolsexport PATH=$&#123;PATH&#125;:/Users/xjw/Library/Android/sdk/tools#配置JDK环境JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_112.jdk/Contents/Homeexport PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport ANDROID_JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_112.jdk/Contents/Home/#源码编译时，需要设置系统的最大值 &lt;br/&gt;ulimit -S -n 1024# MacPorts Installer addition on 2017-03-27_at_10:42:35: adding an appropriate PATH variable for use with MacPorts.export PATH=&quot;/opt/local/bin:/opt/local/sbin:$PATH&quot;# Finished adapting your PATH environment variable for use with MacPorts.","tags":[{"name":"Android源码","slug":"Android源码","permalink":"http://yoursite.com/tags/Android源码/"}]},{"title":"ListView源码解析","date":"2017-03-23T15:23:30.000Z","path":"2017/03/23/ListView源码解析/","text":"ListView -&gt; AbsListView -&gt; RecycleBinRecycleBin -&gt; fillActiveViews 了解RecycleBinRecycleBin是AbsListView的内部类，所以ListView和GridView都有这个类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152/** * Puts a view into the list of scrap views. * &lt;p&gt; * If the list data hasn't changed or the adapter has stable IDs, views * with transient state will be preserved for later retrieval. * * @param scrap The view to add * @param position The view's position within its parent */void addScrapView(View scrap, int position) &#123; final AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams(); if (lp == null) &#123; // Can't recycle, but we don't know anything about the view. // Ignore it completely. return; &#125; lp.scrappedFromPosition = position; // Remove but don't scrap header or footer views, or views that // should otherwise not be recycled. final int viewType = lp.viewType; if (!shouldRecycleViewType(viewType)) &#123; // Can't recycle. If it's not a header or footer, which have // special handling and should be ignored, then skip the scrap // heap and we'll fully detach the view later. if (viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123; getSkippedScrap().add(scrap); &#125; return; &#125; scrap.dispatchStartTemporaryDetach(); // The the accessibility state of the view may change while temporary // detached and we do not allow detached views to fire accessibility // events. So we are announcing that the subtree changed giving a chance // to clients holding on to a view in this subtree to refresh it. notifyViewAccessibilityStateChangedIfNeeded( AccessibilityEvent.CONTENT_CHANGE_TYPE_SUBTREE); // Don't scrap views that have transient state. final boolean scrapHasTransientState = scrap.hasTransientState(); if (scrapHasTransientState) &#123; if (mAdapter != null &amp;&amp; mAdapterHasStableIds) &#123; // If the adapter has stable IDs, we can reuse the view for // the same data. if (mTransientStateViewsById == null) &#123; mTransientStateViewsById = new LongSparseArray&lt;&gt;(); &#125; mTransientStateViewsById.put(lp.itemId, scrap); &#125; else if (!mDataChanged) &#123; // If the data hasn't changed, we can reuse the views at // their old positions. if (mTransientStateViews == null) &#123; mTransientStateViews = new SparseArray&lt;&gt;(); &#125; mTransientStateViews.put(position, scrap); &#125; else &#123; // Otherwise, we'll have to remove the view and start over. getSkippedScrap().add(scrap); &#125; &#125; else &#123; if (mViewTypeCount == 1) &#123; mCurrentScrap.add(scrap); &#125; else &#123; mScrapViews[viewType].add(scrap); &#125; if (mRecyclerListener != null) &#123; mRecyclerListener.onMovedToScrapHeap(scrap); &#125; &#125;&#125; /** * @return A view from the ScrapViews collection. These are unordered. */View getScrapView(int position) &#123; final int whichScrap = mAdapter.getItemViewType(position); if (whichScrap &lt; 0) &#123; return null; &#125; if (mViewTypeCount == 1) &#123; return retrieveFromScrap(mCurrentScrap, position); &#125; else if (whichScrap &lt; mScrapViews.length) &#123; return retrieveFromScrap(mScrapViews[whichScrap], position); &#125; return null;&#125;/** * Fill ActiveViews with all of the children of the AbsListView. * * @param childCount The minimum number of views mActiveViews should hold * @param firstActivePosition The position of the first view that will be stored in * mActiveViews */void fillActiveViews(int childCount, int firstActivePosition) &#123; if (mActiveViews.length &lt; childCount) &#123; mActiveViews = new View[childCount]; &#125; mFirstActivePosition = firstActivePosition; //noinspection MismatchedReadAndWriteOfArray final View[] activeViews = mActiveViews; for (int i = 0; i &lt; childCount; i++) &#123; View child = getChildAt(i); AbsListView.LayoutParams lp = (AbsListView.LayoutParams) child.getLayoutParams(); // Don't put header or footer views into the scrap heap if (lp != null &amp;&amp; lp.viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123; // Note: We do place AdapterView.ITEM_VIEW_TYPE_IGNORE in active views. // However, we will NOT place them into scrap views. activeViews[i] = child; // Remember the position so that setupChild() doesn't reset state. lp.scrappedFromPosition = firstActivePosition + i; &#125; &#125;&#125;/** * Get the view corresponding to the specified position. The view will be removed from * mActiveViews if it is found. * * @param position The position to look up in mActiveViews * @return The view if it is found, null otherwise */View getActiveView(int position) &#123; int index = position - mFirstActivePosition; final View[] activeViews = mActiveViews; if (index &gt;=0 &amp;&amp; index &lt; activeViews.length) &#123; final View match = activeViews[index]; activeViews[index] = null; return match; &#125; return null;&#125;public void setViewTypeCount(int viewTypeCount) &#123; if (viewTypeCount &lt; 1) &#123; throw new IllegalArgumentException(\"Can't have a viewTypeCount &lt; 1\"); &#125; //noinspection unchecked ArrayList&lt;View&gt;[] scrapViews = new ArrayList[viewTypeCount]; for (int i = 0; i &lt; viewTypeCount; i++) &#123; scrapViews[i] = new ArrayList&lt;View&gt;(); &#125; mViewTypeCount = viewTypeCount; mCurrentScrap = scrapViews[0]; mScrapViews = scrapViews;&#125; fillActiveViews()是RecycleBin中的主要方法，第一个参数表示要储存View的个数，第二个参数表示ListView中第一个要出现的View的position。RecycleBin当中使用mActiveViews这个数组来储存View，调用这个方法后就会根据传入的参数来讲ListView中的制定元素储存到mActiveViews数组中。 getActiveView()是和fillActiveViews()相对应的，参数position是用来获取mActiveViews中的View,根据position的值算出mActiveViews的位置，进而从mActiveViews中取出需要的View，取出所需要的View就会从mActiveViews中删除，再次获取同样位置的View会为null,所以mActiveViews是不能重复利用的。 addScrapView()用于存放废弃的View，当传进来的View需要废弃（比如说滚出屏幕外），就调用这个方法来缓存View，其中mCurrentScrap和mScrapViews两个数组来接收View。 getScrapView()同样用来获取缓存的View，从缓存中获取的View是没有顺序的。 setViewTypeCount()是和getViewTypeCount()搭配使用的，来表示ListView中有几种类型的数据项，setViewTypeCount的作用主要是为每种类型的数据项都单独启用一个RecycleBin缓存机制。 以上是RecycleBin中的主要方法，以下是开始分析ListView的工作原理。 第一次LayoutView的执行分为三步，onMeasure()用于测量View的大小，onLayout()用于确定View的布局，onDraw()用于将View绘制到界面上。AbsListView中onMeasure没有特殊的地方，而ListView因为由子元素来负责绘制过程，自身并不负责绘制，所以onDraw()方法在AbsListView中并没有什么意义。只有onLayout方法需要详细介绍。在布局改变的时候，AbsListView会调用onLayout(),onLayout()方法调用layoutChildren()。123456789101112131415161718/** * Subclasses should NOT override this method but &#123;@link #layoutChildren()&#125; * instead. */@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; super.onLayout(changed, l, t, r, b); mInLayout = true; if (changed) &#123; int childCount = getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; getChildAt(i).forceLayout(); &#125; mRecycler.markChildrenDirty(); &#125; layoutChildren(); mInLayout = false;&#125; layoutChildren()需要在ListView中实现，实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223 @Overrideprotected void layoutChildren() &#123; final boolean blockLayoutRequests = mBlockLayoutRequests; if (!blockLayoutRequests) &#123; mBlockLayoutRequests = true; &#125; else &#123; return; &#125; try &#123; super.layoutChildren(); invalidate(); if (mAdapter == null) &#123; resetList(); invokeOnItemScrollListener(); return; &#125; int childrenTop = mListPadding.top; int childrenBottom = getBottom() - getTop() - mListPadding.bottom; int childCount = getChildCount(); int index = 0; int delta = 0; View sel; View oldSel = null; View oldFirst = null; View newSel = null; View focusLayoutRestoreView = null; // Remember stuff we will need down below switch (mLayoutMode) &#123; case LAYOUT_SET_SELECTION: index = mNextSelectedPosition - mFirstPosition; if (index &gt;= 0 &amp;&amp; index &lt; childCount) &#123; newSel = getChildAt(index); &#125; break; case LAYOUT_FORCE_TOP: case LAYOUT_FORCE_BOTTOM: case LAYOUT_SPECIFIC: case LAYOUT_SYNC: break; case LAYOUT_MOVE_SELECTION: default: // Remember the previously selected view index = mSelectedPosition - mFirstPosition; if (index &gt;= 0 &amp;&amp; index &lt; childCount) &#123; oldSel = getChildAt(index); &#125; // Remember the previous first child oldFirst = getChildAt(0); if (mNextSelectedPosition &gt;= 0) &#123; delta = mNextSelectedPosition - mSelectedPosition; &#125; // Caution: newSel might be null newSel = getChildAt(index + delta); &#125; boolean dataChanged = mDataChanged; if (dataChanged) &#123; handleDataChanged(); &#125; // Handle the empty set by removing all views that are visible // and calling it a day if (mItemCount == 0) &#123; resetList(); invokeOnItemScrollListener(); return; &#125; else if (mItemCount != mAdapter.getCount()) &#123; throw new IllegalStateException(\"The content of the adapter has changed but \" + \"ListView did not receive a notification. Make sure the content of \" + \"your adapter is not modified from a background thread, but only \" + \"from the UI thread. [in ListView(\" + getId() + \", \" + getClass() + \") with Adapter(\" + mAdapter.getClass() + \")]\"); &#125; setSelectedPositionInt(mNextSelectedPosition); // Pull all children into the RecycleBin. // These views will be reused if possible final int firstPosition = mFirstPosition; final RecycleBin recycleBin = mRecycler; // reset the focus restoration View focusLayoutRestoreDirectChild = null; // Don't put header or footer views into the Recycler. Those are // already cached in mHeaderViews; if (dataChanged) &#123; for (int i = 0; i &lt; childCount; i++) &#123; recycleBin.addScrapView(getChildAt(i)); if (ViewDebug.TRACE_RECYCLER) &#123; ViewDebug.trace(getChildAt(i), ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP, index, i); &#125; &#125; &#125; else &#123; recycleBin.fillActiveViews(childCount, firstPosition); &#125; // take focus back to us temporarily to avoid the eventual // call to clear focus when removing the focused child below // from messing things up when ViewRoot assigns focus back // to someone else final View focusedChild = getFocusedChild(); if (focusedChild != null) &#123; // TODO: in some cases focusedChild.getParent() == null // we can remember the focused view to restore after relayout if the // data hasn't changed, or if the focused position is a header or footer if (!dataChanged || isDirectChildHeaderOrFooter(focusedChild)) &#123; focusLayoutRestoreDirectChild = focusedChild; // remember the specific view that had focus focusLayoutRestoreView = findFocus(); if (focusLayoutRestoreView != null) &#123; // tell it we are going to mess with it focusLayoutRestoreView.onStartTemporaryDetach(); &#125; &#125; requestFocus(); &#125; // Clear out old views detachAllViewsFromParent(); switch (mLayoutMode) &#123; case LAYOUT_SET_SELECTION: if (newSel != null) &#123; sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom); &#125; else &#123; sel = fillFromMiddle(childrenTop, childrenBottom); &#125; break; case LAYOUT_SYNC: sel = fillSpecific(mSyncPosition, mSpecificTop); break; case LAYOUT_FORCE_BOTTOM: sel = fillUp(mItemCount - 1, childrenBottom); adjustViewsUpOrDown(); break; case LAYOUT_FORCE_TOP: mFirstPosition = 0; sel = fillFromTop(childrenTop); adjustViewsUpOrDown(); break; case LAYOUT_SPECIFIC: sel = fillSpecific(reconcileSelectedPosition(), mSpecificTop); break; case LAYOUT_MOVE_SELECTION: sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom); break; default: if (childCount == 0) &#123; if (!mStackFromBottom) &#123; final int position = lookForSelectablePosition(0, true); setSelectedPositionInt(position); sel = fillFromTop(childrenTop); &#125; else &#123; final int position = lookForSelectablePosition(mItemCount - 1, false); setSelectedPositionInt(position); sel = fillUp(mItemCount - 1, childrenBottom); &#125; &#125; else &#123; if (mSelectedPosition &gt;= 0 &amp;&amp; mSelectedPosition &lt; mItemCount) &#123; sel = fillSpecific(mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop()); &#125; else if (mFirstPosition &lt; mItemCount) &#123; sel = fillSpecific(mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop()); &#125; else &#123; sel = fillSpecific(0, childrenTop); &#125; &#125; break; &#125; // Flush any cached views that did not get reused above recycleBin.scrapActiveViews(); if (sel != null) &#123; // the current selected item should get focus if items // are focusable if (mItemsCanFocus &amp;&amp; hasFocus() &amp;&amp; !sel.hasFocus()) &#123; final boolean focusWasTaken = (sel == focusLayoutRestoreDirectChild &amp;&amp; focusLayoutRestoreView.requestFocus()) || sel.requestFocus(); if (!focusWasTaken) &#123; // selected item didn't take focus, fine, but still want // to make sure something else outside of the selected view // has focus final View focused = getFocusedChild(); if (focused != null) &#123; focused.clearFocus(); &#125; positionSelector(sel); &#125; else &#123; sel.setSelected(false); mSelectorRect.setEmpty(); &#125; &#125; else &#123; positionSelector(sel); &#125; mSelectedTop = sel.getTop(); &#125; else &#123; if (mTouchMode &gt; TOUCH_MODE_DOWN &amp;&amp; mTouchMode &lt; TOUCH_MODE_SCROLL) &#123; View child = getChildAt(mMotionPosition - mFirstPosition); if (child != null) positionSelector(child); &#125; else &#123; mSelectedTop = 0; mSelectorRect.setEmpty(); &#125; // even if there is not selected position, we may need to restore // focus (i.e. something focusable in touch mode) if (hasFocus() &amp;&amp; focusLayoutRestoreView != null) &#123; focusLayoutRestoreView.requestFocus(); &#125; &#125; // tell focus view we are done mucking with it, if it is still in // our view hierarchy. if (focusLayoutRestoreView != null &amp;&amp; focusLayoutRestoreView.getWindowToken() != null) &#123; focusLayoutRestoreView.onFinishTemporaryDetach(); &#125; mLayoutMode = LAYOUT_NORMAL; mDataChanged = false; mNeedSync = false; setNextSelectedPositionInt(mSelectedPosition); updateScrollIndicators(); if (mItemCount &gt; 0) &#123; checkSelectionChanged(); &#125; invokeOnItemScrollListener(); &#125; finally &#123; if (!blockLayoutRequests) &#123; mBlockLayoutRequests = false; &#125; &#125;&#125; 刚开始的时候ListView中肯定没有任何元素，layoutChildren执行的时候没有任何子View，数据还是由Adapter管理，所以getChildCount()得到的值肯定是0。接下来是dataChanged，dataChanged这个值是由AbslistView的父类AdapterView中的mDataChanged得来的,只有在数据源改变的时候才为true。 1234/** * True if the data has changed since the last layout */ boolean mDataChanged; 所以layoutChildren()会调用RecycleBin的fillActiveViews()方法","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"二叉树","date":"2017-03-23T07:42:17.000Z","path":"2017/03/23/二叉树/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188public class Tree &#123; private Node root; public Tree() &#123; root = null; &#125; public Node find(int key) &#123; Node current = root; while(current.iData != key) &#123; if(key &lt; current.iData) &#123;//判断是否小于当前节点的值，如果小查询左树，如果大查询右树 current = current.leftChild; &#125;else&#123; current = current.rightChild; &#125; if(current == null) &#123;//如果当前节点是null代表没有查到 return null; &#125; &#125; return current; &#125; /** * 1、首先获得新插入的newNode * 2、 如果父节点Root==null，newNode就是父节点 * 3、 如果已经有了父节点，先取出父节点parent * 4、判断父节点的值和id的大小，如果id大current移动到父节点的右节点，判断右节点有没有值，如果右节点没有值 * @param id * @param dd */ public void insert(int id, double dd) &#123; Node newNode = new Node(id, dd); if(root == null)&#123; root = newNode; &#125;else&#123; Node current = root; Node parent; while(true) &#123; parent = current;//父节点 if(id &lt; current.iData) &#123; current = current.leftChild; if(current == null) &#123; parent.leftChild = newNode; return; &#125; &#125;else &#123; current = current.rightChild; if(current == null) &#123; parent.rightChild = newNode; return; &#125; &#125; &#125; &#125; &#125; /** * 前序排列 * @param localRoot */ public void preOrder(Node localRoot) &#123; if(localRoot != null) &#123; System.out.println(localRoot.iData + \"\"); preOrder(localRoot.leftChild); preOrder(localRoot.rightChild); &#125; &#125; /** * 中序排列 * @param localRoot */ public void inOrder(Node localRoot) &#123; if(localRoot != null) &#123; inOrder(localRoot.leftChild); System.out.println(localRoot.iData + \"\"); inOrder(localRoot.rightChild); &#125; &#125; /** * 后序排列 * @param localRoot */ public void postOrder(Node localRoot) &#123; if(localRoot != null)&#123; postOrder(localRoot.leftChild); postOrder(localRoot.rightChild); System.out.println(localRoot.iData + \"\"); &#125; &#125; /** * 获得最新节点 * @return */ public Node minimun() &#123; Node current, last = null; current = root; while(current != null) &#123; last = current; current = current.leftChild; &#125; return last; &#125; /** * 删除节点 * @param key * @return */ public boolean delete(int key) &#123; Node current = root; Node parent = root; boolean isLeftChild = true; while(current.iData != key) &#123; parent = current; if(key &lt; current.iData) &#123; isLeftChild = true; current = current.leftChild; &#125;else&#123; isLeftChild = false; current = current.rightChild; &#125; &#125; if (current == null) &#123; return false; &#125; if(current.leftChild == null &amp;&amp; current.rightChild == null) &#123;//没有子节点 if(current == root) &#123;//如果自己是根节点而且没有左右节点，意思就是删除整个树了，变成空数 root = null; &#125;else if(isLeftChild) &#123;//如果不是根节点，同时没有子节点，而是一个父节点的左节点，直接设置为null代表删除 parent.leftChild = null; &#125;else&#123; parent.rightChild = null;//同上，右节点设置为null代表删除 &#125; &#125;else if(current.rightChild == null) &#123;//如果当前节点的右节点是null，代表要删除的节点只有一个左节点 if(current == root) &#123;//是根节点，且有左节点 root = current.leftChild;//把左节点设置成根节点 &#125;else if(isLeftChild) &#123;//当前节点是父节点的左节点，把父节点的左节点设置成当前节点的左节点 parent.leftChild = current.leftChild; &#125;else&#123;//同上 parent.rightChild = current.leftChild; &#125; &#125;else if(current.leftChild == null) &#123;//同上，左节点为空，当前节点是父节点的右节点 if(current == root) &#123; root = current.rightChild; &#125;else if(isLeftChild) &#123; parent.leftChild = current.rightChild; &#125;else&#123; parent.rightChild = current.rightChild; &#125; &#125;else&#123; Node successor = getSuccessor(current); if(current == root) &#123; root = successor; &#125;else if(isLeftChild) &#123; parent.leftChild = successor; &#125;else&#123; parent.rightChild = successor; &#125; successor.leftChild = current.leftChild; &#125; return true; &#125; private Node getSuccessor(Node delNode) &#123; Node successorParent = delNode; Node successor = delNode; Node current = delNode.rightChild; while(current != null) &#123; successorParent = successor; successor = current; current = current.leftChild; &#125; if(successor != delNode.rightChild) &#123; successorParent.leftChild = successor.rightChild; successor.rightChild = delNode.rightChild; &#125; return successor; &#125; &#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"用数组实现栈","date":"2017-03-23T07:33:10.000Z","path":"2017/03/23/用数组实现栈/","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 /** * 栈的建造 * @author A * */public class MyStack &#123; /** * 1. 不能从栈底插入数据 * 2. 不能从栈中间插入数据 * 3. 只能从栈顶插入数据 * 4。 只能通过top访问数据 */ private int[] arr; private int top; public MyStack() &#123; this.arr = new int[10]; top = -1;// 还没有任何元素，所以下标是-1 &#125; public MyStack(int maxSize) &#123; this.arr = new int[maxSize]; top = -1; &#125; //压入数据 public void push(int num) &#123; arr[++top] = num; &#125; public int pop() &#123; return arr[top--]; &#125; public int peek() &#123; return arr[top]; &#125; public boolean isEmpty() &#123; return top == -1; &#125; public boolean isFull() &#123; return top == arr.length - 1; &#125; &#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"用数组实现队列","date":"2017-03-23T02:11:19.000Z","path":"2017/03/23/用数组实现队列/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MyQueue &#123; private int maxSize;// 数组初始化长度 private long[] queue;//队列 private int front;//头指针 private int rear;//尾指针 private int emels;//有效数据 public MyQueue(int size) &#123; this.maxSize= size; queue = new long[size]; front = 0; rear = -1; &#125; public void insert(long j) &#123; if(isFull())&#123; rear = -1; &#125; queue[++rear] = j; emels++; &#125; public long delete() &#123; long tmp = queue[front++]; if(front == maxSize) &#123; front = 0; &#125; emels--; return tmp; &#125; public boolean isEmpty() &#123; return emels == 0; &#125; public boolean isFull() &#123; return emels == maxSize - 1; &#125; public int Size() &#123; return emels; &#125; &#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java多线程的可见性","date":"2017-03-16T03:03:20.000Z","path":"2017/03/16/Java多线程的可见性/","text":"可见性的描述可见性：一个线程对共享的变量进行修改，能够及时的被其他线程看到。共享变量：如果一个变量在多个线程的工作内部中存在副本，那么这个变量就是这几个线程的共享变量。 Java内存模型（JMM）java内存模型描述了java程序中java程序中各种变量（线程共享变量）的访问规则，以及在JVM中将变量储存到内存和从内存中读取出变量这样的底层细节。 所有的变量都储存在主内存中 每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本（主内存中该变量的一份拷贝）。 线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写。 不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。 举个栗子：线程1对共享变量的修改想要被线程2及时看到，必须要经过下面两个步骤 把工作内存1中更新过的共享变量刷新到主内存中 将主内存中最新的共享变量的值更新到工作内存2中可见性的实现首选要保证两点： 线程修改后的共享变量值能够及时从工作内存刷新到主内存中。 其他线程能够及时把共享变量的最新值从主内存更新到自己的工作内存中。 ###Java语言层面关于支持可见性的实现方式 synchronized volatile synchronized能够实现：原子性（同步）、可见性 JMM关于synchroinized的两条规定： 线程解锁前，必须把共享变量的最新值刷新到主内存中。 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值（注意： 加锁与解锁需要时同一把锁）。 线程解锁前对共享变量的修改能再下次加锁时对其他线程可见 线程执行互斥代码的过程： 获得互斥锁 清空工作内存 充主内存拷贝变量的最新副本到工作内存 执行代码 将更改后的共享变量的值刷新到主内存 释放互斥锁 重排序：代码书写的顺序与实际执行的顺序不同，指令重排是编译器或处理器慰问了提高程序性能而做的优化。 编译器优化的重排序（编译器的优化） 指令级并行重排序（处理器优化） 内存系统的重排序（处理器优化）","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java中Lock、synchronized和信号量详解","date":"2017-03-14T09:01:31.000Z","path":"2017/03/14/Java中Lock、synchronized和信号量详解/","text":"","tags":[]},{"title":"进程和线程的区别","date":"2017-03-07T06:55:25.000Z","path":"2017/03/07/进程和线程的区别/","text":"来自阮一峰的博客 计算机的核心是CPU，它承担了所有的计算任务。它就像是一个工厂，时刻在运行。 假设工程的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工时，其他车间必须停滞，这个意思就是单个CPU一次只能运行一个任务。 进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程。 一个车间里，可以有很多工人。他们协同完成一个任务。 线程就好比车间里的工人。一个进程可以包括多个线程。 车间的空间是工人们共享的，比如许多房间是每个工人都可以进入的。象征着一个进程的内存空间是共享的，每个线程都可以共享这片内存。 可是车间的空间是有限的，有些房间最多只能容纳一个人，比如洗手间。当里边有人的时候，其他人不能进入只能在门口等候，这代表一个线程使用某些共享内存的时候，其他线程必须等他结束才能使用这块内存。 一个用来防止他人进入的简单的办法，就是给门口加一把锁。先到的人锁住房间，后边的人看见房间上锁，就会在门口等候。这也就是所谓的“互斥锁”（Mutex），防止多个线程同事读取某一块内存。 还有些房间可以容纳许多人，比如厨房一次只能容纳N个人，多余N个人的时候，其他人必须在门口等候。这就好比某些内存区域只能供给固定数目的线程使用。 这个时候为了解决问题，就需要给门口挂上N把钥匙。进去的人带上一把，出来的时候把钥匙挂在门口。后来的人发现钥匙空了就知道要等待。这种做法叫做“信号量”（Semaphore）,用来保证多个线程不会互相冲突。不难看出，mutex是semaphore的一种特殊情况（n=1）。信号量完全可以代替互斥锁。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。 自己的理解 一、关于进程和线程，首先从定义上理解就有所不同 进程是什么？是具有一定独立功能的程序、它是系统进行资源分配和调度的一个独立单位，重点在系统调度和单独的单位，也就是说进程是可以独立运行的一段程序。 线程又是什么？线程进程的一个实体，是CPU调度和分派的基本单位，他是比进程更小的能独立运行的基本单位，线程自己基本上不拥有系统资源。在运行时，只是暂用一些计数器、寄存器和栈 。 二、他们之间的关系 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程（通常说的主线程）。 资源分配给进程，同一进程的所有线程共享该进程的所有资源。 线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。 处理机分给线程，即真正在处理机上运行的是线程。 线程是指进程内的一个执行单元，也是进程内的可调度实体。 三、从三个角度来剖析二者之间的区别 调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位。 并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行。 拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。","tags":[{"name":"线程","slug":"线程","permalink":"http://yoursite.com/tags/线程/"}]},{"title":"同步锁","date":"2017-03-05T05:07:38.000Z","path":"2017/03/05/同步锁/","text":"","tags":[]},{"title":"ArrayList线程同步的方法","date":"2017-03-04T15:18:15.000Z","path":"2017/03/04/ArrayList线程同步的方法/","text":"ArrayList和Vector的主要区别在于 ArrayList是线程不安全的，但是性能很好，Vector是线程安全的，但性能不行。 ArrayList初始大小是0（以前是10），每次扩容的大小为目前大小的一半。Vector每次扩容为目前大小的一倍。 ArrayList处理线程同步问题的方法有两点 在添加和删除时添加同步锁 123synchronized(arraylistA) &#123; arraylistA.add(new SomeClass()); &#125; 使用集合中的方法： 1List listA = Collections.synchronizedList(new ArrayList()); 这样可以生成一个同步的List，但是当迭代器（Iterator）遍历时，照样需要加上同步锁。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java中自动类型转换","date":"2017-03-02T01:25:26.000Z","path":"2017/03/02/Java中自动类型转换/","text":"自动类型转换遵循下面的规则： 若参与运算的数据类型不同，则先转换成同一类型，然后进行运算。 转换按数据长度增加的方向进行，以保证精度不降低。例如int型和long型运算时，先把int量转成long型后再进行运算。 所有的浮点运算都是以双精度进行的，即使仅含float单精度量运算的表达式，也要先转换成double型，再作运算。 char型和short型参与运算时，必须先转换成int型。 在赋值运算中，赋值号两边的数据类型不同时，需要把右边表达式的类型将转换为左边变量的类型。如果右边表达式的数据类型长度比左边长时，将丢失一部分数据，这样会降低精度。 下图表示了类型自动转换的规则：","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java中的强、软、弱、虚引用","date":"2017-02-28T03:13:52.000Z","path":"2017/02/28/Java中的强、软、弱、虚引用/","text":"基本介绍Java提供了4种引用类型，分别是强引用、软引用（SoftReference）、弱引用（WeakReference）和虚引用（PhantomReference），另外还要一个ReferenceQueue引用队列。引用和引用队列之间的关系对GC垃圾回收有很大的关系。Java中一个很特殊的东西就是垃圾自动回收机制(Garbage Collection，GC),GC可以自动管理内存，开发者不需要手动调用方法回收内存。Java中GC会监控一个对象的运行状态，包括对象的申请、引用、被引用、赋值等，当一个对象没有引用时，就到了被GC回收的时候。 Android中采用了标注与清理（Mark and Sweep）回收算法。 从“GC Roots”开始循环整个内存，当发现有对象不能直接或者间接的到达GC Roots时证明这个对象就应该被GC回收掉了。 如果我们不再需要的对象资源仍然与GC Roots存在可达路径，导致该资源无法被GC回收。 在Android中，每一个应用程序对应有一个单独的Dalvik虚拟机实例，而每一个Dalvik虚拟机的大小是固定的（如32M，可以通过ActivityManager.getMemoryClass()获得）。这意味着我们可以使用的内存不是无节制的。所以即使有着GC帮助我们回收无用内存，还是需要在开发过程中注意对内存的引用。否则，就会导致内存泄露。 1. 强引用(Strong reference) 强引用不会被GC回收掉，举个栗子： Object obj = new Object(),这里的obj就是一个强引用。如果一个对象具有强引用，垃圾回收器是绝对不会回收的。当内存不足时，Java虚拟机宁愿爆出OOM错误也不会回收强引用对象来解决内存不足的问题。假设有对象A和对象B，A中存在B的引用，那么B的生命周期不会比A短，如果在A中不对B赋值null的话，只有回收A的时候才能把B回收掉。 2. 软引用(Soft reference)软引用会在内存不足的时候由GC回收掉，软引用一般用于处理缓存数据。 3. 弱引用(Weak reference)弱引用在GC遍历内存时就会被回收掉，不管内存是否不足。如果一个对象的所有引用都是弱引用，该对象一定会被回收。 4. 虚引用一个只被虚引用持有的对象可能会在任何时候被GC回收。虚引用对对象的生存周期完全没有影响，也无法通过虚引用来获取对象实例，仅仅能在对象被回收时，得到一个系统通知（只能通过是否被加入到ReferenceQueue来判断是否被GC，这也是唯一判断对象是否被GC的途径） ß","tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"}]},{"title":"android：largeHeap属性的用法","date":"2017-02-26T15:13:29.000Z","path":"2017/02/26/android：largeHeap属性的用法/","text":"如果遇到OutOfMemoryError这样的崩溃，产生的原因主要有两部分，一时内存太小不够用了，二是代码有误，不能及时释放内存，基本后者的情况遇到的最多。这时，我们可以考虑使用android:largeHeap属性来解决内存不够用的问题。 基础概念我们先了解一下关于程序设计中关于内存的基础概念。 通常情况下，一个Android程序运行时会启动一个DVM虚拟机。 虚拟机运行时一般分为堆和栈两大部门。（关于堆和栈的理解以后再讲） 栈是储存方法调用的一片内存区域。 堆内存占用了虚拟机大部分的内存空间，程序执行时产生的对象就分配在堆内存中。 如果堆内存没用可用的空间来产生对象，JVM会抛出java.lang.OutOfMemoryError异常。 largeHeap的介绍如果开启了largeHeap后，程序会请求系统给予分配更大的内存空间。使用方法如下： 1234567&lt;application android:icon=\"@drawable/icon\" android:allowBackup=\"false\" android:label=\"@string/app_name\" android:debuggable=\"true\" android:theme=\"@android:style/Theme.Black\" android:largeHeap=\"true\"&gt; largeHeap 有多大通过两个方法可以得到。 ActivityManager.getMemoryClass()获得内用正常情况下内存的大小 ActivityManager.getLargeMemoryClass()可以获得开启largeHeap最大的内存大小 Android系统中文件路径/system/build.prop下可以得到结果。 123456dalvik.vm.heapstartsize=8mdalvik.vm.heapgrowthlimit=192mdalvik.vm.heapsize=512mdalvik.vm.heaptargetutilization=0.75dalvik.vm.heapminfree=2mdalvik.vm.heapmaxfree=8m dalvik.vm.heapstartsize=8m 这一项用来设置堆内存的初始大小。 dalvik.vm.heapgrowthlimit=192m 这一项用来设置一个标准应用的最大内存大小，即是没有使用过largeHeap的内存大小。 dalvik.vm.heapsize=512m 相当于虚拟机的 -Xmx配置，该项设置了使用android:largeHeap的应用的最大堆内存大小。 dalvik.vm.heaptargetutilization=0.75 相当于虚拟机的 -XX:HeapTargetUtilization,该项用来设置当前理想的堆内存利用率。其取值位于0与1之间。当GC进行完垃圾回收之后，Dalvik的堆内存会进行相应的调整，通常结果是当前存活的对象的大小与堆内存大小做除法，得到的值为这个选项的设置，即这里的0.75。注意，这只是一个参考值，Dalvik虚拟机也可以忽略此设置。 dalvik.vm.heapminfree=2m与dalvik.vm.heapmaxfree=8m dalvik.vm.heapminfree对应的是-XX:HeapMinFree配置，用来设置单次堆内存调整的最小值。dalvik.vm.heapmaxfree对应的是-XX:HeapMaxFree配置，用来设置单次堆内存调整的最大值。通常情况下，还需要结合上面的 -XX:HeapTargetUtilization的值，才能确定内存调整时，需要调整的大小。 largeHeap需要权限吗只需要简单在Application元素上加入android:largeHeap=“true”就能正常使用，不需要权限。 largeHeap对GC的影响拥有了更多的内存，是不是就意味着要花更多的时间遍历对象垃圾回收呢？其实不然。 首先largeHeap自Android 4.0开始支持，而并发的垃圾回收方式从Android 2.3开始引入。 在引入并发垃圾回收之前，系统采用了Stop-the-World回收方式，进行一次垃圾回收通常消耗几百毫秒，这是很影响交互和响应的。 引入并发垃圾回收之后,在GC开始和结束的阶段会有短暂的暂停时间，通常在10毫秒以内。 因此在支持largeHeap的系统上都采用了并发垃圾回收，GC的Pause Time不会很长，对交互响应影响甚微。 慎用largeHeap对于largeHeap的使用，我们该持有的谨慎的态度，largeHeap可以使用，但是要谨慎。 对于本身对内存要求过大的图片或者视频应用，我们可以使用largeHeap。","tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"}]},{"title":"聊一聊单例模式","date":"2017-02-16T06:44:01.000Z","path":"2017/02/16/聊一聊单例模式/","text":"单例模式是Android项目中最常用的设计模式。 饿汉式,通过静态变量实现。常驻内存，不使用时资源浪费。 12345678910class SingleInstance &#123; private static SingleInstance sInstance = new SingleInstance(); private SingleInstance() &#123; &#125; public static SingleInstance getInstance() &#123; return sInstance; &#125;&#125; 懒汉式，第一次使用时创建，解决饿汉式的资源浪费问题，但是有并发问题。 1234567891011121314class SingleInstance() &#123; private static SingleInstance sInstance; private SingleInstance() &#123; &#125; public static SingleInstance getInstance() &#123; if (null == sInstance )&#123; sInstance = new SingleInstance(); &#125; return sInstance; &#125;&#125; synchronized修饰符，可以解决懒汉式中多线程并发的问题。但是用在getInstance方法上会导致性能下降，而且getInstance方法会调用多次。 123456789101112class SingleInstance &#123; private static SingleInstance sInstance; private SingleInstance() &#123; &#125; public synchronized static getInstance() &#123; if (null == sInstance )&#123; sInstance = new SingleInstance(); &#125; return sInstance; &#125;&#125; 双重判断模式 1234567891011121314151617class SingleInstance&#123; private static SingleInstance sInstance; private SingleInstance() &#123; &#125; public static SingleInstance getInstance() &#123; if(null == sInstance) &#123; synchronized(SingleInstance.class)&#123; if(null == sInstance) &#123; sInstance = new SingleInstance(); &#125; &#125; &#125; return sInstance; &#125;&#125; volatile关键字，volatile关键字是轻型的synchronized,","tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"}]}]