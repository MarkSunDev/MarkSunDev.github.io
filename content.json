[{"title":"聊一聊单例模式","date":"2017-02-16T06:44:01.000Z","path":"2017/02/16/聊一聊单例模式/Dev","text":"聊一聊单例模式 饿汉式,通过静态变量实现。常驻内存，不使用时资源浪费。 12345678910class SingleInstance &#123; private static SingleInstance sInstance = new SingleInstance(); private SingleInstance() &#123; &#125; public static SingleInstance getInstance() &#123; return sInstance; &#125;&#125; 懒汉式，第一次使用时创建，解决饿汉式的资源浪费问题，但是有并发问题。 1234567891011121314class SingleInstance() &#123; private static SingleInstance sInstance; private SingleInstance() &#123; &#125; public static SingleInstance getInstance() &#123; if (null == sInstance )&#123; sInstance = new SingleInstance(); &#125; return sInstance; &#125;&#125; synchronized修饰符，可以解决懒汉式中多线程并发的问题。但是用在getInstance方法上会导致性能下降，而且getInstance方法会调用多次。 123456789101112class SingleInstance &#123; private static SingleInstance sInstance; private SingleInstance() &#123; &#125; public synchronized static getInstance() &#123; if (null == sInstance )&#123; sInstance = new SingleInstance(); &#125; return sInstance; &#125;&#125; 双重判断模式 1234567891011121314151617class SingleInstance&#123; private static SingleInstance sInstance; private SingleInstance() &#123; &#125; public static SingleInstance getInstance() &#123; if(null == sInstance) &#123; synchronized(SingleInstance.class)&#123; if(null == sInstance) &#123; sInstance = new SingleInstance(); &#125; &#125; &#125; return sInstance; &#125;&#125; volatile关键字，volatile关键字是轻型的synchronized,","tags":[]}]