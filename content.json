[{"title":"Java多线程的可见性","date":"2017-03-16T03:03:20.000Z","path":"2017/03/16/Java多线程的可见性/","text":"可见性的描述可见性：一个线程对共享的变量进行修改，能够及时的被其他线程看到。共享变量：如果一个变量在多个线程的工作内部中存在副本，那么这个变量就是这几个线程的共享变量。 Java内存模型（JMM）java内存模型描述了java程序中java程序中各种变量（线程共享变量）的访问规则，以及在JVM中将变量储存到内存和从内存中读取出变量这样的底层细节。 所有的变量都储存在主内存中 每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本（主内存中该变量的一份拷贝）。 线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写。 不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。 举个栗子：线程1对共享变量的修改想要被线程2及时看到，必须要经过下面两个步骤 把工作内存1中更新过的共享变量刷新到主内存中 将主内存中最新的共享变量的值更新到工作内存2中可见性的实现首选要保证两点： 线程修改后的共享变量值能够及时从工作内存刷新到主内存中。 其他线程能够及时把共享变量的最新值从主内存更新到自己的工作内存中。 ###Java语言层面关于支持可见性的实现方式 synchronized volatile synchronized能够实现：原子性（同步）、可见性 JMM关于synchroinized的两条规定： 线程解锁前，必须把共享变量的最新值刷新到主内存中。 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值（注意： 加锁与解锁需要时同一把锁）。 线程解锁前对共享变量的修改能再下次加锁时对其他线程可见 线程执行互斥代码的过程： 获得互斥锁 清空工作内存 充主内存拷贝变量的最新副本到工作内存 执行代码 将更改后的共享变量的值刷新到主内存 释放互斥锁 重排序：代码书写的顺序与实际执行的顺序不同，指令重排是编译器或处理器慰问了提高程序性能而做的优化。 编译器优化的重排序（编译器的优化） 指令级并行重排序（处理器优化） 内存系统的重排序（处理器优化）","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java中Lock、synchronized和信号量详解","date":"2017-03-14T09:01:31.000Z","path":"2017/03/14/Java中Lock、synchronized和信号量详解/","text":"","tags":[]},{"title":"进程和线程的区别","date":"2017-03-07T06:55:25.000Z","path":"2017/03/07/进程和线程的区别/","text":"来自阮一峰的博客 计算机的核心是CPU，它承担了所有的计算任务。它就像是一个工厂，时刻在运行。 假设工程的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工时，其他车间必须停滞，这个意思就是单个CPU一次只能运行一个任务。 进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程。 一个车间里，可以有很多工人。他们协同完成一个任务。 线程就好比车间里的工人。一个进程可以包括多个线程。 车间的空间是工人们共享的，比如许多房间是每个工人都可以进入的。象征着一个进程的内存空间是共享的，每个线程都可以共享这片内存。 可是车间的空间是有限的，有些房间最多只能容纳一个人，比如洗手间。当里边有人的时候，其他人不能进入只能在门口等候，这代表一个线程使用某些共享内存的时候，其他线程必须等他结束才能使用这块内存。 一个用来防止他人进入的简单的办法，就是给门口加一把锁。先到的人锁住房间，后边的人看见房间上锁，就会在门口等候。这也就是所谓的“互斥锁”（Mutex），防止多个线程同事读取某一块内存。 还有些房间可以容纳许多人，比如厨房一次只能容纳N个人，多余N个人的时候，其他人必须在门口等候。这就好比某些内存区域只能供给固定数目的线程使用。 这个时候为了解决问题，就需要给门口挂上N把钥匙。进去的人带上一把，出来的时候把钥匙挂在门口。后来的人发现钥匙空了就知道要等待。这种做法叫做“信号量”（Semaphore）,用来保证多个线程不会互相冲突。不难看出，mutex是semaphore的一种特殊情况（n=1）。信号量完全可以代替互斥锁。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。 自己的理解 一、关于进程和线程，首先从定义上理解就有所不同 进程是什么？是具有一定独立功能的程序、它是系统进行资源分配和调度的一个独立单位，重点在系统调度和单独的单位，也就是说进程是可以独立运行的一段程序。 线程又是什么？线程进程的一个实体，是CPU调度和分派的基本单位，他是比进程更小的能独立运行的基本单位，线程自己基本上不拥有系统资源。在运行时，只是暂用一些计数器、寄存器和栈 。 二、他们之间的关系 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程（通常说的主线程）。 资源分配给进程，同一进程的所有线程共享该进程的所有资源。 线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。 处理机分给线程，即真正在处理机上运行的是线程。 线程是指进程内的一个执行单元，也是进程内的可调度实体。 三、从三个角度来剖析二者之间的区别 调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位。 并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行。 拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。","tags":[{"name":"线程","slug":"线程","permalink":"http://yoursite.com/tags/线程/"}]},{"title":"同步锁","date":"2017-03-05T05:07:38.000Z","path":"2017/03/05/同步锁/","text":"","tags":[]},{"title":"ArrayList线程同步的方法","date":"2017-03-04T14:49:06.000Z","path":"2017/03/04/ArrayList线程同步的方法/","text":"ArrayList和Vector的主要区别在于 ArrayList是线程不安全的，但是性能很好，Vector是线程安全的，但性能不行。 ArrayList初始大小是0（以前是10），每次扩容的大小为目前大小的一半。Vector每次扩容为目前大小的一倍。 ArrayList处理线程同步问题的方法有两点 在添加和删除时添加同步锁 123synchronized(arraylistA) &#123; arraylistA.add(new SomeClass()); &#125; 使用集合中的方法： 1List listA = Collections.synchronizedList(new ArrayList()); 这样可以生成一个同步的List，但是当迭代器（Iterator）遍历时，照样需要加上同步锁。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java中自动类型转换","date":"2017-03-02T01:25:26.000Z","path":"2017/03/02/Java中自动类型转换/","text":"自动类型转换遵循下面的规则： 若参与运算的数据类型不同，则先转换成同一类型，然后进行运算。 转换按数据长度增加的方向进行，以保证精度不降低。例如int型和long型运算时，先把int量转成long型后再进行运算。 所有的浮点运算都是以双精度进行的，即使仅含float单精度量运算的表达式，也要先转换成double型，再作运算。 char型和short型参与运算时，必须先转换成int型。 在赋值运算中，赋值号两边的数据类型不同时，需要把右边表达式的类型将转换为左边变量的类型。如果右边表达式的数据类型长度比左边长时，将丢失一部分数据，这样会降低精度。 下图表示了类型自动转换的规则：","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java中的强、软、弱、虚引用","date":"2017-02-28T03:13:52.000Z","path":"2017/02/28/Java中的强、软、弱、虚引用/","text":"基本介绍Java提供了4种引用类型，分别是强引用、软引用（SoftReference）、弱引用（WeakReference）和虚引用（PhantomReference），另外还要一个ReferenceQueue引用队列。引用和引用队列之间的关系对GC垃圾回收有很大的关系。Java中一个很特殊的东西就是垃圾自动回收机制(Garbage Collection，GC),GC可以自动管理内存，开发者不需要手动调用方法回收内存。Java中GC会监控一个对象的运行状态，包括对象的申请、引用、被引用、赋值等，当一个对象没有引用时，就到了被GC回收的时候。 Android中采用了标注与清理（Mark and Sweep）回收算法。 从“GC Roots”开始循环整个内存，当发现有对象不能直接或者间接的到达GC Roots时证明这个对象就应该被GC回收掉了。 如果我们不再需要的对象资源仍然与GC Roots存在可达路径，导致该资源无法被GC回收。 在Android中，每一个应用程序对应有一个单独的Dalvik虚拟机实例，而每一个Dalvik虚拟机的大小是固定的（如32M，可以通过ActivityManager.getMemoryClass()获得）。这意味着我们可以使用的内存不是无节制的。所以即使有着GC帮助我们回收无用内存，还是需要在开发过程中注意对内存的引用。否则，就会导致内存泄露。 1. 强引用(Strong reference) 强引用不会被GC回收掉，举个栗子： Object obj = new Object(),这里的obj就是一个强引用。如果一个对象具有强引用，垃圾回收器是绝对不会回收的。当内存不足时，Java虚拟机宁愿爆出OOM错误也不会回收强引用对象来解决内存不足的问题。假设有对象A和对象B，A中存在B的引用，那么B的生命周期不会比A短，如果在A中不对B赋值null的话，只有回收A的时候才能把B回收掉。 2. 软引用(Soft reference)软引用会在内存不足的时候由GC回收掉，软引用一般用于处理缓存数据。 3. 弱引用(Weak reference)弱引用在GC遍历内存时就会被回收掉，不管内存是否不足。如果一个对象的所有引用都是弱引用，该对象一定会被回收。 4. 虚引用一个只被虚引用持有的对象可能会在任何时候被GC回收。虚引用对对象的生存周期完全没有影响，也无法通过虚引用来获取对象实例，仅仅能在对象被回收时，得到一个系统通知（只能通过是否被加入到ReferenceQueue来判断是否被GC，这也是唯一判断对象是否被GC的途径） ß","tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"}]},{"title":"android：largeHeap属性的用法","date":"2017-02-26T15:13:29.000Z","path":"2017/02/26/android：largeHeap属性的用法/","text":"如果遇到OutOfMemoryError这样的崩溃，产生的原因主要有两部分，一时内存太小不够用了，二是代码有误，不能及时释放内存，基本后者的情况遇到的最多。这时，我们可以考虑使用android:largeHeap属性来解决内存不够用的问题。 基础概念我们先了解一下关于程序设计中关于内存的基础概念。 通常情况下，一个Android程序运行时会启动一个DVM虚拟机。 虚拟机运行时一般分为堆和栈两大部门。（关于堆和栈的理解以后再讲） 栈是储存方法调用的一片内存区域。 堆内存占用了虚拟机大部分的内存空间，程序执行时产生的对象就分配在堆内存中。 如果堆内存没用可用的空间来产生对象，JVM会抛出java.lang.OutOfMemoryError异常。 largeHeap的介绍如果开启了largeHeap后，程序会请求系统给予分配更大的内存空间。使用方法如下： 1234567&lt;application android:icon=\"@drawable/icon\" android:allowBackup=\"false\" android:label=\"@string/app_name\" android:debuggable=\"true\" android:theme=\"@android:style/Theme.Black\" android:largeHeap=\"true\"&gt; largeHeap 有多大通过两个方法可以得到。 ActivityManager.getMemoryClass()获得内用正常情况下内存的大小 ActivityManager.getLargeMemoryClass()可以获得开启largeHeap最大的内存大小 Android系统中文件路径/system/build.prop下可以得到结果。 123456dalvik.vm.heapstartsize=8mdalvik.vm.heapgrowthlimit=192mdalvik.vm.heapsize=512mdalvik.vm.heaptargetutilization=0.75dalvik.vm.heapminfree=2mdalvik.vm.heapmaxfree=8m dalvik.vm.heapstartsize=8m 这一项用来设置堆内存的初始大小。 dalvik.vm.heapgrowthlimit=192m 这一项用来设置一个标准应用的最大内存大小，即是没有使用过largeHeap的内存大小。 dalvik.vm.heapsize=512m 相当于虚拟机的 -Xmx配置，该项设置了使用android:largeHeap的应用的最大堆内存大小。 dalvik.vm.heaptargetutilization=0.75 相当于虚拟机的 -XX:HeapTargetUtilization,该项用来设置当前理想的堆内存利用率。其取值位于0与1之间。当GC进行完垃圾回收之后，Dalvik的堆内存会进行相应的调整，通常结果是当前存活的对象的大小与堆内存大小做除法，得到的值为这个选项的设置，即这里的0.75。注意，这只是一个参考值，Dalvik虚拟机也可以忽略此设置。 dalvik.vm.heapminfree=2m与dalvik.vm.heapmaxfree=8m dalvik.vm.heapminfree对应的是-XX:HeapMinFree配置，用来设置单次堆内存调整的最小值。dalvik.vm.heapmaxfree对应的是-XX:HeapMaxFree配置，用来设置单次堆内存调整的最大值。通常情况下，还需要结合上面的 -XX:HeapTargetUtilization的值，才能确定内存调整时，需要调整的大小。 largeHeap需要权限吗只需要简单在Application元素上加入android:largeHeap=“true”就能正常使用，不需要权限。 largeHeap对GC的影响拥有了更多的内存，是不是就意味着要花更多的时间遍历对象垃圾回收呢？其实不然。 首先largeHeap自Android 4.0开始支持，而并发的垃圾回收方式从Android 2.3开始引入。 在引入并发垃圾回收之前，系统采用了Stop-the-World回收方式，进行一次垃圾回收通常消耗几百毫秒，这是很影响交互和响应的。 引入并发垃圾回收之后,在GC开始和结束的阶段会有短暂的暂停时间，通常在10毫秒以内。 因此在支持largeHeap的系统上都采用了并发垃圾回收，GC的Pause Time不会很长，对交互响应影响甚微。 慎用largeHeap对于largeHeap的使用，我们该持有的谨慎的态度，largeHeap可以使用，但是要谨慎。 对于本身对内存要求过大的图片或者视频应用，我们可以使用largeHeap。","tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"}]},{"title":"聊一聊单例模式","date":"2017-02-16T06:44:01.000Z","path":"2017/02/16/聊一聊单例模式/","text":"单例模式是Android项目中最常用的设计模式。 饿汉式,通过静态变量实现。常驻内存，不使用时资源浪费。 12345678910class SingleInstance &#123; private static SingleInstance sInstance = new SingleInstance(); private SingleInstance() &#123; &#125; public static SingleInstance getInstance() &#123; return sInstance; &#125;&#125; 懒汉式，第一次使用时创建，解决饿汉式的资源浪费问题，但是有并发问题。 1234567891011121314class SingleInstance() &#123; private static SingleInstance sInstance; private SingleInstance() &#123; &#125; public static SingleInstance getInstance() &#123; if (null == sInstance )&#123; sInstance = new SingleInstance(); &#125; return sInstance; &#125;&#125; synchronized修饰符，可以解决懒汉式中多线程并发的问题。但是用在getInstance方法上会导致性能下降，而且getInstance方法会调用多次。 123456789101112class SingleInstance &#123; private static SingleInstance sInstance; private SingleInstance() &#123; &#125; public synchronized static getInstance() &#123; if (null == sInstance )&#123; sInstance = new SingleInstance(); &#125; return sInstance; &#125;&#125; 双重判断模式 1234567891011121314151617class SingleInstance&#123; private static SingleInstance sInstance; private SingleInstance() &#123; &#125; public static SingleInstance getInstance() &#123; if(null == sInstance) &#123; synchronized(SingleInstance.class)&#123; if(null == sInstance) &#123; sInstance = new SingleInstance(); &#125; &#125; &#125; return sInstance; &#125;&#125; volatile关键字，volatile关键字是轻型的synchronized,","tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"}]}]