[{"title":"android：largeHeap属性的用法","date":"2017-02-26T15:13:29.000Z","path":"2017/02/26/android：largeHeap属性的用法/","text":"如果遇到OutOfMemoryError这样的崩溃，产生的原因主要有两部分，一时内存太小不够用了，二是代码有误，不能及时释放内存，基本后者的情况遇到的最多。这时，我们可以考虑使用android:largeHeap属性来解决内存不够用的问题。 基础概念我们先了解一下关于程序设计中关于内存的基础概念。 通常情况下，一个Android程序运行时会启动一个DVM虚拟机。 虚拟机运行时一般分为堆和栈两大部门。（关于堆和栈的理解以后再讲） 栈是储存方法调用的一片内存区域。 堆内存占用了虚拟机大部分的内存空间，程序执行时产生的对象就分配在堆内存中。 如果堆内存没用可用的空间来产生对象，JVM会抛出java.lang.OutOfMemoryError异常。 largeHeap的介绍如果开启了largeHeap后，程序会请求系统给予分配更大的内存空间。使用方法如下： 1234567&lt;application android:icon=\"@drawable/icon\" android:allowBackup=\"false\" android:label=\"@string/app_name\" android:debuggable=\"true\" android:theme=\"@android:style/Theme.Black\" android:largeHeap=\"true\"&gt; largeHeap 有多大通过两个方法可以得到。 ActivityManager.getMemoryClass()获得内用正常情况下内存的大小 ActivityManager.getLargeMemoryClass()可以获得开启largeHeap最大的内存大小 Android系统中文件路径/system/build.prop下可以得到结果。 123456dalvik.vm.heapstartsize=8mdalvik.vm.heapgrowthlimit=192mdalvik.vm.heapsize=512mdalvik.vm.heaptargetutilization=0.75dalvik.vm.heapminfree=2mdalvik.vm.heapmaxfree=8m dalvik.vm.heapstartsize=8m 这一项用来设置堆内存的初始大小。 dalvik.vm.heapgrowthlimit=192m 这一项用来设置一个标准应用的最大内存大小，即是没有使用过largeHeap的内存大小。 dalvik.vm.heapsize=512m 相当于虚拟机的 -Xmx配置，该项设置了使用android:largeHeap的应用的最大堆内存大小。 dalvik.vm.heaptargetutilization=0.75 相当于虚拟机的 -XX:HeapTargetUtilization,该项用来设置当前理想的堆内存利用率。其取值位于0与1之间。当GC进行完垃圾回收之后，Dalvik的堆内存会进行相应的调整，通常结果是当前存活的对象的大小与堆内存大小做除法，得到的值为这个选项的设置，即这里的0.75。注意，这只是一个参考值，Dalvik虚拟机也可以忽略此设置。 dalvik.vm.heapminfree=2m与dalvik.vm.heapmaxfree=8m dalvik.vm.heapminfree对应的是-XX:HeapMinFree配置，用来设置单次堆内存调整的最小值。dalvik.vm.heapmaxfree对应的是-XX:HeapMaxFree配置，用来设置单次堆内存调整的最大值。通常情况下，还需要结合上面的 -XX:HeapTargetUtilization的值，才能确定内存调整时，需要调整的大小。 largeHeap需要权限吗只需要简单在Application元素上加入android:largeHeap=“true”就能正常使用，不需要权限。 largeHeap对GC的影响拥有了更多的内存，是不是就意味着要花更多的时间遍历对象垃圾回收呢？其实不然。 首先largeHeap自Android 4.0开始支持，而并发的垃圾回收方式从Android 2.3开始引入。 在引入并发垃圾回收之前，系统采用了Stop-the-World回收方式，进行一次垃圾回收通常消耗几百毫秒，这是很影响交互和响应的。 引入并发垃圾回收之后,在GC开始和结束的阶段会有短暂的暂停时间，通常在10毫秒以内。 因此在支持largeHeap的系统上都采用了并发垃圾回收，GC的Pause Time不会很长，对交互响应影响甚微。 慎用largeHeap对于largeHeap的使用，我们该持有的谨慎的态度，largeHeap可以使用，但是要谨慎。 对于本身对内存要求过大的图片或者视频应用，我们可以使用largeHeap。","tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"}]},{"title":"聊一聊单例模式","date":"2017-02-16T06:44:01.000Z","path":"2017/02/16/聊一聊单例模式/","text":"单例模式是Android项目中最常用的设计模式。 饿汉式,通过静态变量实现。常驻内存，不使用时资源浪费。 12345678910class SingleInstance &#123; private static SingleInstance sInstance = new SingleInstance(); private SingleInstance() &#123; &#125; public static SingleInstance getInstance() &#123; return sInstance; &#125;&#125; 懒汉式，第一次使用时创建，解决饿汉式的资源浪费问题，但是有并发问题。 1234567891011121314class SingleInstance() &#123; private static SingleInstance sInstance; private SingleInstance() &#123; &#125; public static SingleInstance getInstance() &#123; if (null == sInstance )&#123; sInstance = new SingleInstance(); &#125; return sInstance; &#125;&#125; synchronized修饰符，可以解决懒汉式中多线程并发的问题。但是用在getInstance方法上会导致性能下降，而且getInstance方法会调用多次。 123456789101112class SingleInstance &#123; private static SingleInstance sInstance; private SingleInstance() &#123; &#125; public synchronized static getInstance() &#123; if (null == sInstance )&#123; sInstance = new SingleInstance(); &#125; return sInstance; &#125;&#125; 双重判断模式 1234567891011121314151617class SingleInstance&#123; private static SingleInstance sInstance; private SingleInstance() &#123; &#125; public static SingleInstance getInstance() &#123; if(null == sInstance) &#123; synchronized(SingleInstance.class)&#123; if(null == sInstance) &#123; sInstance = new SingleInstance(); &#125; &#125; &#125; return sInstance; &#125;&#125; volatile关键字，volatile关键字是轻型的synchronized,","tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"}]}]